use core::f64;
use std::fs::File;
use std::io::{BufWriter, Write};

use shapefile::dbase::{FieldValue, Record};
use shapefile::{read_as, Polyline};
use tiff::decoder::{Decoder, DecodingResult};

use crate::constants::BUFFER;
use crate::tile::Tile;

pub fn pullautin_smooth_contours(tile: &Tile) -> Vec<Vec<f64>> {
    println!("Smooth curves...");
    let scalefactor: f64 = 1.0;
    let smoothing: f64 = 0.7;
    let curviness: f64 = 1.1;
    let indexcontours: f64 = 25.;
    let contour_interval: f64 = 5.0;
    let halfinterval = contour_interval / 2.0 * scalefactor;

    let size: f64 = 2.0;
    let xstart: f64 = (tile.min_x - BUFFER as i64) as f64;
    let ystart: f64 = (tile.min_y - BUFFER as i64) as f64;

    let xmax: u64 = (tile.max_x + BUFFER as i64 - xstart as i64) as u64 / 2;
    let ymax: u64 = (tile.max_y + BUFFER as i64 - ystart as i64) as u64 / 2;

    let avg_alt = get_elevation_matrix_from_dem(tile);
    let mut steepness = vec![vec![f64::NAN; (ymax + 2) as usize]; (xmax + 2) as usize];

    // Computing a basic steepness matrix
    for i in 1..xmax {
        for j in 1..ymax {
            let mut low: f64 = f64::MAX;
            let mut high: f64 = f64::MIN;
            for ii in i - 1..i + 2 {
                for jj in j - 1..j + 2 {
                    let tmp = avg_alt[ii as usize][jj as usize];

                    if tmp < low {
                        low = tmp;
                    }
                    if tmp > high {
                        high = tmp;
                    }
                }
            }

            steepness[i as usize][j as usize] = high - low;
        }
    }

    let dxfheadtmp = format!("\r\n  9\r\n$EXTMIN\r\n 10\r\n{}\r\n 20\r\n{}\r\n  9\r\n$EXTMAX\r\n 10\r\n{}\r\n 20\r\n{}\r\n  0\r\n", xstart, ystart, xmax, ymax);
    let dxfhead = &format!("HEADER{}ENDSEC", dxfheadtmp);
    let mut out = String::new();
    out.push_str("  0\r\nSECTION\r\n  2\r\n");
    out.push_str(dxfhead);
    out.push_str("\r\n  0\r\nSECTION\r\n  2\r\nENTITIES\r\n  0\r\n");

    let mut el_x = Vec::<Vec<f64>>::new();
    let mut el_y = Vec::<Vec<f64>>::new();
    let mut elevations = Vec::<f64>::new();

    let contours_polylines_path = tile.dir_path.join("contours-raw.shp");
    let contours_polylines = read_as::<_, Polyline, Record>(contours_polylines_path)
        .expect("Could not open contours_polylines shapefile");

    for (line, record) in contours_polylines {
        let mut x_array = Vec::<f64>::new();
        let mut y_array = Vec::<f64>::new();

        for part in line.parts() {
            for point in part {
                x_array.push(point.x);
                y_array.push(point.y + 2.); // There was a 2 metters offset between pullautin's raw contours and the one generated by GDAL. Keeping this offset so it doesn't disturb the smoothin process
            }
        }

        let elevation = match record.get("elev") {
            Some(FieldValue::Numeric(Some(x))) => x,
            Some(_) => &f64::NAN,
            None => panic!("Field 'elev' is not within polygon-dataset"),
        };

        el_x.push(x_array);
        el_y.push(y_array);
        elevations.push(*elevation);
    }

    // Smoothing merged contours
    for l in 0..el_x.len() {
        let mut el_x_len = el_x[l].len();

        if el_x_len < 15 {
            continue;
        }

        let height = elevations[l];

        // Smoothing contours, differenciating between index, normal and formline countours and writing it to contours.dxf
        // adaptive generalization
        if el_x_len > 101 {
            let mut newx: Vec<f64> = vec![];
            let mut newy: Vec<f64> = vec![];
            let mut xpre = el_x[l][0];
            let mut ypre = el_y[l][0];

            newx.push(el_x[l][0]);
            newy.push(el_y[l][0]);

            for k in 1..(el_x_len - 1) {
                let xx = ((el_x[l][k] - xstart) / size + 0.5).floor() as usize;
                let yy = ((el_y[l][k] - ystart) / size + 0.5).floor() as usize;

                let ss = steepness[xx][yy];
                if ss.is_nan() || ss < 0.5 {
                    if ((xpre - el_x[l][k]).powi(2) + (ypre - el_y[l][k]).powi(2)).sqrt() >= 4.0 {
                        newx.push(el_x[l][k]);
                        newy.push(el_y[l][k]);
                        xpre = el_x[l][k];
                        ypre = el_y[l][k];
                    }
                } else {
                    newx.push(el_x[l][k]);
                    newy.push(el_y[l][k]);
                    xpre = el_x[l][k];
                    ypre = el_y[l][k];
                }
            }
            newx.push(el_x[l][el_x_len - 1]);
            newy.push(el_y[l][el_x_len - 1]);

            el_x[l].clear();
            el_x[l].append(&mut newx);
            el_y[l].clear();
            el_y[l].append(&mut newy);
            el_x_len = el_x[l].len();
        }
        // Smoothing
        let mut dx: Vec<f64> = vec![f64::NAN; el_x_len];
        let mut dy: Vec<f64> = vec![f64::NAN; el_x_len];

        for k in 2..(el_x_len - 3) {
            dx[k] = (el_x[l][k - 2]
                + el_x[l][k - 1]
                + el_x[l][k]
                + el_x[l][k + 1]
                + el_x[l][k + 2]
                + el_x[l][k + 3])
                / 6.0;
            dy[k] = (el_y[l][k - 2]
                + el_y[l][k - 1]
                + el_y[l][k]
                + el_y[l][k + 1]
                + el_y[l][k + 2]
                + el_y[l][k + 3])
                / 6.0;
        }

        let mut xa: Vec<f64> = vec![f64::NAN; el_x_len];
        let mut ya: Vec<f64> = vec![f64::NAN; el_x_len];
        for k in 1..(el_x_len - 1) {
            xa[k] = (el_x[l][k - 1] + el_x[l][k] / (0.01 + smoothing) + el_x[l][k + 1])
                / (2.0 + 1.0 / (0.01 + smoothing));
            ya[k] = (el_y[l][k - 1] + el_y[l][k] / (0.01 + smoothing) + el_y[l][k + 1])
                / (2.0 + 1.0 / (0.01 + smoothing));
        }

        if el_x[l].first() == el_x[l].last() && el_y[l].first() == el_y[l].last() {
            let vx = (el_x[l][1] + el_x[l][0] / (0.01 + smoothing) + el_x[l][el_x_len - 2])
                / (2.0 + 1.0 / (0.01 + smoothing));
            let vy = (el_y[l][1] + el_y[l][0] / (0.01 + smoothing) + el_y[l][el_x_len - 2])
                / (2.0 + 1.0 / (0.01 + smoothing));
            xa[0] = vx;
            ya[0] = vy;
            xa[el_x_len - 1] = vx;
            ya[el_x_len - 1] = vy;
        } else {
            xa[0] = el_x[l][0];
            ya[0] = el_y[l][0];
            xa[el_x_len - 1] = el_x[l][el_x_len - 1];
            ya[el_x_len - 1] = el_y[l][el_x_len - 1];
        }
        for k in 1..(el_x_len - 1) {
            el_x[l][k] = (xa[k - 1] + xa[k] / (0.01 + smoothing) + xa[k + 1])
                / (2.0 + 1.0 / (0.01 + smoothing));
            el_y[l][k] = (ya[k - 1] + ya[k] / (0.01 + smoothing) + ya[k + 1])
                / (2.0 + 1.0 / (0.01 + smoothing));
        }
        if xa.first() == xa.last() && ya.first() == ya.last() {
            let vx = (xa[1] + xa[0] / (0.01 + smoothing) + xa[el_x_len - 2])
                / (2.0 + 1.0 / (0.01 + smoothing));
            let vy = (ya[1] + ya[0] / (0.01 + smoothing) + ya[el_x_len - 2])
                / (2.0 + 1.0 / (0.01 + smoothing));
            el_x[l][0] = vx;
            el_y[l][0] = vy;
            el_x[l][el_x_len - 1] = vx;
            el_y[l][el_x_len - 1] = vy;
        } else {
            el_x[l][0] = xa[0];
            el_y[l][0] = ya[0];
            el_x[l][el_x_len - 1] = xa[el_x_len - 1];
            el_y[l][el_x_len - 1] = ya[el_x_len - 1];
        }

        for k in 1..(el_x_len - 1) {
            xa[k] = (el_x[l][k - 1] + el_x[l][k] / (0.01 + smoothing) + el_x[l][k + 1])
                / (2.0 + 1.0 / (0.01 + smoothing));
            ya[k] = (el_y[l][k - 1] + el_y[l][k] / (0.01 + smoothing) + el_y[l][k + 1])
                / (2.0 + 1.0 / (0.01 + smoothing));
        }

        if el_x[l].first() == el_x[l].last() && el_y[l].first() == el_y[l].last() {
            let vx = (el_x[l][1] + el_x[l][0] / (0.01 + smoothing) + el_x[l][el_x_len - 2])
                / (2.0 + 1.0 / (0.01 + smoothing));
            let vy = (el_y[l][1] + el_y[l][0] / (0.01 + smoothing) + el_y[l][el_x_len - 2])
                / (2.0 + 1.0 / (0.01 + smoothing));
            xa[0] = vx;
            ya[0] = vy;
            xa[el_x_len - 1] = vx;
            ya[el_x_len - 1] = vy;
        } else {
            xa[0] = el_x[l][0];
            ya[0] = el_y[l][0];
            xa[el_x_len - 1] = el_x[l][el_x_len - 1];
            ya[el_x_len - 1] = el_y[l][el_x_len - 1];
        }
        for k in 0..el_x_len {
            el_x[l][k] = xa[k];
            el_y[l][k] = ya[k];
        }

        let mut dx2: Vec<f64> = vec![f64::NAN; el_x_len];
        let mut dy2: Vec<f64> = vec![f64::NAN; el_x_len];
        for k in 2..(el_x_len - 3) {
            dx2[k] = (el_x[l][k - 2]
                + el_x[l][k - 1]
                + el_x[l][k]
                + el_x[l][k + 1]
                + el_x[l][k + 2]
                + el_x[l][k + 3])
                / 6.0;
            dy2[k] = (el_y[l][k - 2]
                + el_y[l][k - 1]
                + el_y[l][k]
                + el_y[l][k + 1]
                + el_y[l][k + 2]
                + el_y[l][k + 3])
                / 6.0;
        }
        for k in 3..(el_x_len - 3) {
            let vx = el_x[l][k] + (dx[k] - dx2[k]) * curviness;
            let vy = el_y[l][k] + (dy[k] - dy2[k]) * curviness;
            el_x[l][k] = vx;
            el_y[l][k] = vy;
        }

        let mut layer = String::from("contour");

        if height.round() as isize % indexcontours as isize == 0 {
            layer.push_str("_index");
        } else if height.round() as isize % contour_interval as isize != 0
            && (height * 2.).round() as isize % (halfinterval * 2.).round() as isize == 0
        {
            layer.push_str("_intermed");
        }

        out.push_str(
            format!(
                "POLYLINE\r\n 66\r\n1\r\n  8\r\n{}\r\n 38\r\n{}\r\n  0\r\n",
                layer, height
            )
            .as_str(),
        );

        for k in 0..el_x_len {
            out.push_str(
                format!(
                    "VERTEX\r\n  8\r\n{}\r\n 10\r\n{}\r\n 20\r\n{}\r\n 30\r\n{}\r\n  0\r\n",
                    layer, el_x[l][k], el_y[l][k], height
                )
                .as_str(),
            );
        }

        out.push_str("SEQEND\r\n  0\r\n");
    }

    out.push_str("ENDSEC\r\n  0\r\nEOF\r\n");
    let output = tile.dir_path.join("contours.dxf");
    let fp = File::create(output).expect("Unable to create file");
    let mut fp = BufWriter::new(fp);
    fp.write_all(out.as_bytes()).expect("Unable to write file");
    println!("Done");

    return avg_alt;
}

fn get_elevation_matrix_from_dem(tile: &Tile) -> Vec<Vec<f64>> {
    let dem_path = tile.dir_path.join("dem-low-resolution-with-buffer.tif");
    let dem_tif_file = File::open(dem_path).expect("Cannot find dem tif image!");

    let mut dem_img_decoder = Decoder::new(dem_tif_file).expect("Cannot create decoder");
    dem_img_decoder = dem_img_decoder.with_limits(tiff::decoder::Limits::unlimited());

    let (dem_width, dem_height) = dem_img_decoder.dimensions().unwrap();

    let w: usize = dem_width as usize;
    let h: usize = dem_height as usize;
    let mut avg_alt = vec![vec![f64::NAN; h + 2]; w + 2];

    let DecodingResult::F64(image_data) = dem_img_decoder.read_image().unwrap() else {
        panic!("Cannot read band data")
    };

    // Building avg_alt matrix and defining hmin and hmax
    for index in 0..image_data.len() {
        let x = index % usize::try_from(dem_width).unwrap();
        let y = usize::try_from(dem_height).unwrap() - index / usize::try_from(dem_height).unwrap();
        let elevation = image_data[index] as f64;
        avg_alt[x][y] = elevation;
    }

    return avg_alt;
}
